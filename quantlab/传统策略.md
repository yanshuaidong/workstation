# 传统短线趋势策略研究体系

> **目标**：基于 Backtrader 搭建一套可复用的"短线趋势策略研究体系"，包含 3-4 个经典策略族 + 组合风控 + 研究流程。

---

## 一、环境架构

本项目遵循 **数据与量化分离** 的设计原则：

```
workstation/
├── database/futures/
│   ├── futures.db          # SQLite 数据库（只读）
│   └── README.md           # 数据库表结构说明
│
└── quantlab/               # 量化研究目录
    ├── 传统策略.md          # 本文档
    ├── core/               # 通用模块
    │   ├── data_loader.py  # 数据加载器（从 futures.db 读取）
    │   ├── backtest.py     # Backtrader 回测封装
    │   ├── metrics.py      # 绩效指标计算
    │   └── portfolio.py    # 组合风控
    │
    ├── strategies/         # 策略族定义
    │   ├── breakout.py     # 短周期突破族
    │   ├── ma_trend.py     # 均线趋势族
    │   ├── momentum.py     # 动量持有族
    │   └── atr_channel.py  # ATR 通道族
    │
    ├── research/           # 研究结果输出
    │   ├── experiments/    # 实验记录
    │   └── results/        # 回测结果（csv、图表）
    │
    └── notebooks/          # Jupyter 探索分析
```

### 1.1 数据源说明

数据已存储在 `../database/futures/futures.db`：

| 表名 | 说明 |
|------|------|
| `contracts_main` | 合约主表（symbol, name, exchange, is_active） |
| `hist_{symbol}` | 历史行情表（trade_date, OHLCV, open_interest） |

**已入库品种**：76 个主连合约，时间范围 2018-01-01 ~ 2024-12-31

### 1.2 依赖安装

```bash
pip install backtrader pandas numpy matplotlib
```

---

## 二、数据加载模块

> 位置：`quantlab/core/data_loader.py`

从 SQLite 数据库加载数据，转换为 Backtrader 可用的 Data Feed。

```python
"""
数据加载器 - 从 futures.db 读取主连数据
"""
import sqlite3
import pandas as pd
from pathlib import Path
import backtrader as bt

# 数据库路径（相对于 quantlab 目录）
DB_PATH = Path(__file__).parent.parent.parent / "database" / "futures" / "futures.db"


def get_available_symbols() -> list:
    """获取所有可用品种列表"""
    with sqlite3.connect(DB_PATH) as conn:
        df = pd.read_sql("SELECT symbol, name FROM contracts_main WHERE is_active = 1", conn)
    return df.to_dict('records')


def load_symbol_data(symbol: str, start_date: str = None, end_date: str = None) -> pd.DataFrame:
    """
    加载单个品种的历史数据
    
    Args:
        symbol: 品种代码（如 'rbm', 'cum'）
        start_date: 开始日期 'YYYY-MM-DD'
        end_date: 结束日期 'YYYY-MM-DD'
    
    Returns:
        DataFrame with columns: date, open, high, low, close, volume, openinterest
    """
    table_name = f"hist_{symbol.lower()}"
    
    query = f"""
        SELECT trade_date, open_price, high_price, low_price, close_price, volume, open_interest
        FROM {table_name}
        WHERE 1=1
    """
    if start_date:
        query += f" AND trade_date >= '{start_date}'"
    if end_date:
        query += f" AND trade_date <= '{end_date}'"
    query += " ORDER BY trade_date"
    
    with sqlite3.connect(DB_PATH) as conn:
        df = pd.read_sql(query, conn)
    
    # 转换为 Backtrader 标准列名
    df.columns = ['date', 'open', 'high', 'low', 'close', 'volume', 'openinterest']
    df['date'] = pd.to_datetime(df['date'])
    df.set_index('date', inplace=True)
    
    return df


def create_bt_datafeed(symbol: str, start_date: str = None, end_date: str = None) -> bt.feeds.PandasData:
    """
    创建 Backtrader DataFeed 对象
    
    Args:
        symbol: 品种代码
        start_date: 开始日期
        end_date: 结束日期
    
    Returns:
        bt.feeds.PandasData 对象
    """
    df = load_symbol_data(symbol, start_date, end_date)
    
    data = bt.feeds.PandasData(
        dataname=df,
        datetime=None,  # index 即为日期
        open='open',
        high='high',
        low='low',
        close='close',
        volume='volume',
        openinterest='openinterest'
    )
    
    return data


def load_multi_symbols(symbols: list, start_date: str = None, end_date: str = None) -> dict:
    """
    加载多个品种数据
    
    Returns:
        dict: {symbol: bt.feeds.PandasData}
    """
    feeds = {}
    for symbol in symbols:
        try:
            feeds[symbol] = create_bt_datafeed(symbol, start_date, end_date)
        except Exception as e:
            print(f"Warning: 加载 {symbol} 失败 - {e}")
    return feeds
```

---

## 三、通用回测框架

> 位置：`quantlab/core/backtest.py`

### 3.1 交易假设配置

```python
"""
回测配置与框架
"""
import backtrader as bt
from dataclasses import dataclass


@dataclass
class TradeConfig:
    """交易假设配置"""
    # 信号在 T 日收盘生成，T+1 日开盘成交
    signal_delay: int = 1
    use_next_open: bool = True
    
    # 手续费（双边，按成交额比例）
    commission_rate: float = 0.0001  # 1bp
    
    # 滑点（按点数）
    slippage_points: int = 1
    
    # 初始资金
    initial_cash: float = 1_000_000


class BacktestEngine:
    """统一回测入口"""
    
    def __init__(self, config: TradeConfig = None):
        self.config = config or TradeConfig()
        self.cerebro = bt.Cerebro()
        self._setup_broker()
    
    def _setup_broker(self):
        """配置 Broker"""
        self.cerebro.broker.setcash(self.config.initial_cash)
        self.cerebro.broker.setcommission(commission=self.config.commission_rate)
    
    def add_data(self, data, name: str = None):
        """添加数据"""
        self.cerebro.adddata(data, name=name)
    
    def add_strategy(self, strategy_cls, **kwargs):
        """添加策略"""
        self.cerebro.addstrategy(strategy_cls, **kwargs)
    
    def add_analyzers(self):
        """添加分析器"""
        self.cerebro.addanalyzer(bt.analyzers.SharpeRatio, _name='sharpe')
        self.cerebro.addanalyzer(bt.analyzers.DrawDown, _name='drawdown')
        self.cerebro.addanalyzer(bt.analyzers.Returns, _name='returns')
        self.cerebro.addanalyzer(bt.analyzers.TradeAnalyzer, _name='trades')
    
    def run(self, plot: bool = False):
        """执行回测"""
        self.add_analyzers()
        results = self.cerebro.run()
        
        if plot:
            self.cerebro.plot(style='candlestick')
        
        return results[0]  # 返回策略实例
```

### 3.2 绩效分析模块

> 位置：`quantlab/core/metrics.py`

```python
"""
绩效指标计算
"""

def extract_metrics(strategy_result) -> dict:
    """从回测结果提取关键指标"""
    metrics = {}
    
    # Sharpe Ratio
    sharpe = strategy_result.analyzers.sharpe.get_analysis()
    metrics['sharpe_ratio'] = sharpe.get('sharperatio', None)
    
    # Drawdown
    dd = strategy_result.analyzers.drawdown.get_analysis()
    metrics['max_drawdown'] = dd.get('max', {}).get('drawdown', None)
    metrics['max_drawdown_len'] = dd.get('max', {}).get('len', None)
    
    # Returns
    returns = strategy_result.analyzers.returns.get_analysis()
    metrics['total_return'] = returns.get('rtot', None)
    metrics['avg_return'] = returns.get('ravg', None)
    
    # Trades
    trades = strategy_result.analyzers.trades.get_analysis()
    metrics['total_trades'] = trades.get('total', {}).get('total', 0)
    metrics['won_trades'] = trades.get('won', {}).get('total', 0)
    metrics['lost_trades'] = trades.get('lost', {}).get('total', 0)
    
    if metrics['total_trades'] > 0:
        metrics['win_rate'] = metrics['won_trades'] / metrics['total_trades']
    else:
        metrics['win_rate'] = 0
    
    return metrics


def print_metrics(metrics: dict):
    """打印绩效报告"""
    print("\n" + "=" * 50)
    print("绩效报告")
    print("=" * 50)
    print(f"Sharpe Ratio:    {metrics.get('sharpe_ratio', 'N/A'):.3f}" if metrics.get('sharpe_ratio') else "Sharpe Ratio:    N/A")
    print(f"Total Return:    {metrics.get('total_return', 0) * 100:.2f}%")
    print(f"Max Drawdown:    {metrics.get('max_drawdown', 0):.2f}%")
    print(f"Total Trades:    {metrics.get('total_trades', 0)}")
    print(f"Win Rate:        {metrics.get('win_rate', 0) * 100:.1f}%")
    print("=" * 50)
```

---

## 四、策略族定义

### 4.1 策略族 1：短周期突破族

> 位置：`quantlab/strategies/breakout.py`

**核心理念**：Donchian 突破的短周期版本，捕捉 3-10 日单边走势。

```python
"""
短周期突破策略族
"""
import backtrader as bt


class ShortTermBreakout(bt.Strategy):
    """
    短周期突破策略
    
    参数:
        n_high: 突破周期（HH_N）
        n_low: 平仓周期（LL_M）
        atr_period: ATR 计算周期
        max_hold: 最大持有天数
        stop_atr_mult: 止损 ATR 倍数
    """
    params = dict(
        n_high=5,       # N: 3, 5, 7, 10
        n_low=3,        # M: N/2 or N
        atr_period=14,  # L: 10, 14, 20
        max_hold=7,     # H: 5, 7, 10
        stop_atr_mult=2.0,  # K: 1.5, 2, 2.5
    )
    
    def __init__(self):
        # 指标
        self.highest = bt.indicators.Highest(self.data.high, period=self.p.n_high)
        self.lowest = bt.indicators.Lowest(self.data.low, period=self.p.n_low)
        self.atr = bt.indicators.ATR(self.data, period=self.p.atr_period)
        
        # 状态
        self.entry_price = None
        self.entry_bar = None
        self.order = None
    
    def next(self):
        if self.order:  # 有未完成订单，跳过
            return
        
        if not self.position:  # 无持仓
            # 多头入场：收盘价突破 N 日最高
            if self.data.close[0] > self.highest[-1]:
                self.order = self.buy()
                self.entry_price = self.data.close[0]
                self.entry_bar = len(self)
        
        else:  # 有持仓
            hold_days = len(self) - self.entry_bar
            stop_price = self.entry_price - self.p.stop_atr_mult * self.atr[0]
            
            # 出场条件
            should_exit = (
                self.data.close[0] < self.lowest[-1] or  # 跌破 M 日最低
                hold_days >= self.p.max_hold or          # 持有超限
                self.data.close[0] < stop_price          # 止损
            )
            
            if should_exit:
                self.order = self.close()
                self.entry_price = None
                self.entry_bar = None
    
    def notify_order(self, order):
        if order.status in [order.Completed, order.Canceled, order.Rejected]:
            self.order = None
```

### 4.2 策略族 2：短周期均线趋势族

> 位置：`quantlab/strategies/ma_trend.py`

**核心理念**：短均线跟随，适合 3-10 日趋势。

```python
"""
短周期均线趋势策略族
"""
import backtrader as bt


class ShortTermMATrend(bt.Strategy):
    """
    短周期均线趋势策略
    
    参数:
        ma_short: 短期均线周期
        ma_long: 长期均线周期
        atr_period: ATR 计算周期
        max_hold: 最大持有天数
        stop_atr_mult: 止损 ATR 倍数
    """
    params = dict(
        ma_short=5,     # n1: 3, 4, 5
        ma_long=10,     # n2: 8, 10, 12, 15
        atr_period=14,  # L: 10, 14, 20
        max_hold=7,     # H: 5, 7, 10
        stop_atr_mult=2.0,  # K: 1.5, 2, 2.5
    )
    
    def __init__(self):
        # 指标
        self.ma_short = bt.indicators.SMA(self.data.close, period=self.p.ma_short)
        self.ma_long = bt.indicators.SMA(self.data.close, period=self.p.ma_long)
        self.atr = bt.indicators.ATR(self.data, period=self.p.atr_period)
        
        # 金叉死叉信号
        self.crossover = bt.indicators.CrossOver(self.ma_short, self.ma_long)
        
        # 状态
        self.entry_price = None
        self.entry_bar = None
        self.order = None
    
    def next(self):
        if self.order:
            return
        
        if not self.position:
            # 多头入场：短均线上穿长均线
            if self.crossover[0] > 0:
                self.order = self.buy()
                self.entry_price = self.data.close[0]
                self.entry_bar = len(self)
        
        else:
            hold_days = len(self) - self.entry_bar
            stop_price = self.entry_price - self.p.stop_atr_mult * self.atr[0]
            
            should_exit = (
                self.crossover[0] < 0 or              # 死叉
                hold_days >= self.p.max_hold or       # 持有超限
                self.data.close[0] < stop_price       # 止损
            )
            
            if should_exit:
                self.order = self.close()
                self.entry_price = None
                self.entry_bar = None
    
    def notify_order(self, order):
        if order.status in [order.Completed, order.Canceled, order.Rejected]:
            self.order = None
```

### 4.3 策略族 3：N 日动量 + 固定持有族

> 位置：`quantlab/strategies/momentum.py`

**核心理念**：用最近 N 日累计涨幅判断趋势，固定持有 3-10 日。

```python
"""
N 日动量 + 固定持有策略族
"""
import backtrader as bt


class MomentumFixHold(bt.Strategy):
    """
    动量固定持有策略
    
    参数:
        lookback: 动量回看周期
        threshold: 入场阈值（百分比）
        hold_days: 固定持有天数
        atr_period: ATR 计算周期
        stop_atr_mult: 止损 ATR 倍数
    """
    params = dict(
        lookback=5,      # k: 3, 5, 7
        threshold=0.02,  # T_up: 1%, 2%, 3%
        hold_days=5,     # H: 3, 5, 7, 10
        atr_period=14,
        stop_atr_mult=2.0,
    )
    
    def __init__(self):
        # 动量指标：k 日收益率
        self.momentum = bt.indicators.ROC(self.data.close, period=self.p.lookback)
        self.atr = bt.indicators.ATR(self.data, period=self.p.atr_period)
        
        # 状态
        self.entry_price = None
        self.entry_bar = None
        self.order = None
    
    def next(self):
        if self.order:
            return
        
        if not self.position:
            # 多头入场：k 日动量超过阈值
            if self.momentum[0] / 100 > self.p.threshold:
                self.order = self.buy()
                self.entry_price = self.data.close[0]
                self.entry_bar = len(self)
        
        else:
            hold_days = len(self) - self.entry_bar
            stop_price = self.entry_price - self.p.stop_atr_mult * self.atr[0]
            
            should_exit = (
                hold_days >= self.p.hold_days or      # 固定持有到期
                self.data.close[0] < stop_price       # 止损
            )
            
            if should_exit:
                self.order = self.close()
                self.entry_price = None
                self.entry_bar = None
    
    def notify_order(self, order):
        if order.status in [order.Completed, order.Canceled, order.Rejected]:
            self.order = None
```

### 4.4 策略族 4：ATR 通道族（可选）

> 位置：`quantlab/strategies/atr_channel.py`

**核心理念**：用 ATR 做价格通道，捕捉波动放大后的趋势。

```python
"""
ATR 通道趋势策略族
"""
import backtrader as bt


class ATRChannelTrend(bt.Strategy):
    """
    ATR 通道策略
    
    参数:
        ma_period: 基础均线周期
        atr_period: ATR 计算周期
        channel_mult: 通道 ATR 倍数
        max_hold: 最大持有天数
    """
    params = dict(
        ma_period=10,     # MA 周期: 10, 20
        atr_period=14,    # ATR 周期: 10, 14, 20
        channel_mult=2.0, # C: 1.5, 2, 2.5
        max_hold=10,      # H: 5, 7, 10
    )
    
    def __init__(self):
        # 指标
        self.ma = bt.indicators.SMA(self.data.close, period=self.p.ma_period)
        self.atr = bt.indicators.ATR(self.data, period=self.p.atr_period)
        
        # 通道
        self.upper = self.ma + self.p.channel_mult * self.atr
        self.lower = self.ma - self.p.channel_mult * self.atr
        
        # 状态
        self.entry_bar = None
        self.order = None
    
    def next(self):
        if self.order:
            return
        
        if not self.position:
            # 多头入场：突破上轨
            if self.data.close[0] > self.upper[-1]:
                self.order = self.buy()
                self.entry_bar = len(self)
        
        else:
            hold_days = len(self) - self.entry_bar
            
            should_exit = (
                self.data.close[0] < self.ma[0] or    # 跌回均线
                self.data.close[0] < self.lower[0] or # 跌破下轨
                hold_days >= self.p.max_hold          # 持有超限
            )
            
            if should_exit:
                self.order = self.close()
                self.entry_bar = None
    
    def notify_order(self, order):
        if order.status in [order.Completed, order.Canceled, order.Rejected]:
            self.order = None
```

---

## 五、快速开始示例

> 位置：`quantlab/example_run.py`

```python
"""
快速开始示例 - 单品种回测
"""
import sys
from pathlib import Path

# 添加项目路径
sys.path.insert(0, str(Path(__file__).parent))

from core.data_loader import create_bt_datafeed, get_available_symbols
from core.backtest import BacktestEngine, TradeConfig
from core.metrics import extract_metrics, print_metrics
from strategies.breakout import ShortTermBreakout


def run_single_backtest():
    """单品种单策略回测示例"""
    
    # 1. 加载数据
    print("加载数据: rbm (螺纹钢主连)")
    data = create_bt_datafeed('rbm', start_date='2020-01-01', end_date='2023-12-31')
    
    # 2. 创建回测引擎
    config = TradeConfig(initial_cash=1_000_000)
    engine = BacktestEngine(config)
    
    # 3. 添加数据和策略
    engine.add_data(data, name='rbm')
    engine.add_strategy(ShortTermBreakout, n_high=5, n_low=3, max_hold=7)
    
    # 4. 运行回测
    print("运行回测...")
    result = engine.run(plot=False)
    
    # 5. 输出结果
    metrics = extract_metrics(result)
    print_metrics(metrics)
    
    return result


if __name__ == '__main__':
    run_single_backtest()
```

---

## 六、研究流程

### 6.1 时间划分

| 阶段 | 时间范围 | 用途 |
|------|----------|------|
| 训练期 | 2018-2021 | 参数调优 |
| 验证期 | 2022-2023 | 选择稳健参数 |
| 测试期 | 2024 | 最终评估 |

### 6.2 参数网格研究

```python
"""
参数网格搜索示例
"""
from itertools import product
import pandas as pd

# 参数空间
param_grid = {
    'n_high': [3, 5, 7, 10],
    'n_low': [3, 5],
    'max_hold': [5, 7, 10],
    'stop_atr_mult': [1.5, 2.0, 2.5],
}

# 生成所有参数组合
combinations = list(product(*param_grid.values()))
print(f"共 {len(combinations)} 个参数组合")

# TODO: 实现参数遍历并保存结果
```

### 6.3 稳健性检查

- 参数平面是否存在"连续的不错区域"
- 不同品种上表现是否一致
- 样本外是否稳定

---

## 七、TODO 清单

### 第一阶段：基础框架（1-2 天）

- [ ] 创建 `quantlab/core/` 目录结构
- [ ] 实现 `data_loader.py` 数据加载模块
- [ ] 实现 `backtest.py` 回测框架
- [ ] 实现 `metrics.py` 绩效模块
- [ ] 测试：单品种空策略验证框架正确

### 第二阶段：策略实现（3-5 天）

- [ ] 实现 `ShortTermBreakout` 短周期突破策略
- [ ] 实现 `ShortTermMATrend` 均线趋势策略
- [ ] 实现 `MomentumFixHold` 动量持有策略
- [ ] 单品种调试验证每个策略逻辑正确

### 第三阶段：参数研究（3-5 天）

- [ ] 实现参数网格搜索脚本
- [ ] 在训练期跑参数优化
- [ ] 在验证期筛选稳健参数
- [ ] 输出研究报告到 `research/`

### 第四阶段：组合风控（2-3 天）

- [ ] 实现 `portfolio.py` 组合层风控
- [ ] 单笔风险 R 机制
- [ ] 多品种组合回测

---

## 八、备注

### 可用品种列表

从数据库加载，共 76 个主连品种，主要类别：

| 类别 | 品种示例 |
|------|----------|
| 黑色 | rbm (螺纹), hcm (热卷), im (铁矿), jm (焦炭), jmm (焦煤) |
| 有色 | cum (铜), alm (铝), znm (锌), nim (镍), pbm (铅) |
| 能化 | scm (原油), fum (燃油), tam (PTA), mam (甲醇), egm (乙二醇) |
| 农产 | cm (玉米), mm (豆粕), ym (豆油), srm (白糖), cfm (棉花) |
| 贵金属 | aum (黄金), agm (白银) |
| 金融 | ifm (沪深300), icm (中证500), tm (十债) |

### 数据质量说明

- 数据时间范围：2018-01-01 ~ 2024-12-31
- 部分品种上市较晚，数据条数不足 1698 条
- 涨跌停标记暂未处理（后续可在数据库层面补充）
