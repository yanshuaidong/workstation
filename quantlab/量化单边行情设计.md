你是一名资深量化工程师，熟悉 Python、pandas、传统机器学习（尤其是 XGBoost / LightGBM / scikit-learn），也熟悉 SQLite 与期货时间序列回测。

我要你**直接写出完整可运行的 Python 代码**，实现一个从 SQLite 数据库读取数据 → 识别 3–10 日单边行情 → 打标签 → 特征工程 → 使用传统机器学习训练模型 → 简单策略回测 的完整流程。

特别要求：
- 只能使用传统机器学习（树模型、逻辑回归等），**禁止使用任何深度学习框架**（禁止 PyTorch、TensorFlow、Keras 等）。
- 不需要 GPU，加速全部用 CPU。
- 数据来源是一个名为 `futures.db` 的 SQLite 数据库，结构如下。

==================================================
【一、数据来源：SQLite futures.db 的表结构】
==================================================

数据库文件：`futures.db`
数据时间范围：2025 年 1 月至 11 月（共约 220 个交易日）

1. 合约主表：`contracts_main`

表结构（列名和含义如下）：

- `symbol`      TEXT PRIMARY KEY   合约代码（如 AU0, CU0）
- `name`        TEXT NOT NULL      合约名称（如 沪金主连）
- `exchange`    TEXT               交易所代码（如 SHFE, DCE）
- `is_active`   INTEGER DEFAULT 1  是否活跃（1=活跃, 0=非活跃）
- `created_at`  TEXT               创建时间
- `updated_at`  TEXT               更新时间

2. 历史行情表：每个合约一个独立表

- 表名格式：`hist_` + 合约代码小写，例如：symbol = 'AU0' → 表名 `hist_au0`
- 每个历史行情表字段：

  - `trade_date`    TEXT PRIMARY KEY   交易日期（YYYY-MM-DD）
  - `open_price`    REAL               开盘价
  - `high_price`    REAL               最高价
  - `low_price`     REAL               最低价
  - `close_price`   REAL               收盘价
  - `volume`        INTEGER            成交量（手）
  - `open_interest` INTEGER            持仓量（手）

==================================================
【二、整体代码结构与技术栈要求】
==================================================

1. 主要使用库：
   - sqlite3 或 SQLAlchemy（任选其一，sqlite3 更简单即可）
   - pandas
   - numpy
   - scikit-learn
   - lightgbm 或 xgboost（至少实现 LightGBM 版本）
   - matplotlib（可选，用于简单画图）

2. 所有代码写在**一个 .py 文件**中（例如 `futures_trend_ml.py`），我可以直接复制粘贴运行。

3. 代码结构建议拆成以下模块/函数（全部放在同一文件中）：
   - 数据读取与整合：
     - 连接 SQLite
     - 从 `contracts_main` 读取活跃合约（`is_active=1`）
     - 遍历这些合约，拼接对应的 `hist_{symbol.lower()}` 表数据，统一成一个总的 DataFrame
   - 单边行情识别与打标签
   - 特征工程（只用过去信息）
   - 时间序列划分训练集 / 验证集 / 测试集
   - 使用 LightGBM 的传统机器学习训练模型
   - 用模型概率生成交易信号 + 简单回测

4. 所有关键函数需要有清晰的 docstring 和中文注释，说明输入输出。

==================================================
【三、数据读取与基础预处理】
==================================================

请实现如下逻辑：

1. 写一个函数：
   - `get_active_contracts(conn) -> List[str]`
   - 功能：从 `contracts_main` 中查询所有 `is_active = 1` 的 `symbol`，返回 symbol 列表。

2. 写一个函数：
   - `load_history_from_db(db_path: str) -> pd.DataFrame`
   - 功能：
     - 连接 `futures.db`
     - 通过 `get_active_contracts` 获取活跃合约列表
     - 对每个 symbol：
       - 构造该合约的历史表名：`hist_` + symbol.lower()
       - 使用 `pd.read_sql_query` 从该表读取所有行
       - 把字段重命名成统一格式：
         - `trade_date` → `date`
         - `open_price` → `open`
         - `high_price` → `high`
         - `low_price` → `low`
         - `close_price` → `close`
         - `volume` → `volume`
         - `open_interest` → `open_interest`
       - 增加一列：`symbol` = 当前合约代码
     - 把所有合约的数据拼接成一个总表 `df_all`：
       - 包含：`date`, `symbol`, `open`, `high`, `low`, `close`, `volume`, `open_interest`
       - 将 `date` 转换为 datetime 类型
       - 按 `symbol`、`date` 排序
     - 返回 `df_all`

3. 在后续所有处理中，都以这个 `df_all` 为基础。

==================================================
【四、单边行情（3–10 日）识别与打标签】
==================================================

目标：从历史数据中自动识别 3–10 日的单边行情段（上涨或下跌），并把每段切成“前 / 中 / 后”阶段，然后给每一天打标签用于监督学习。

请按以下规则实现：

1. 按品种分组：
   - 对每个 `symbol` 的子 DataFrame（按 date 排序）单独处理。

2. 对每个起点日 t 和每个窗口长度 L ∈ [3, 10]：
   - 计算上涨候选：
     - R_up = (close[t+L-1] - close[t]) / close[t]
   - 计算下跌候选：
     - R_down = (close[t] - close[t+L-1]) / close[t]   （取正数，表示沿下跌方向的幅度）

3. 计算“最大逆向波动”：
   - 对上涨候选：
     - 区间 [t, t+L-1] 取最低价 low_min
     - 最大回撤 = (close[t] - low_min) / close[t]
   - 对下跌候选：
     - 区间 [t, t+L-1] 取最高价 high_max
     - 最大反弹 = (high_max - close[t]) / close[t]

4. 使用波动自适应阈值：
   - 为每个品种预先计算 20 日 ATR 或 20 日真实波动率（可用简单 ATR 实现）。
   - 设参数：
     - k1（总幅度相对 ATR 的倍数，默认 2.0）
     - max_reverse_ratio（最大逆向波动比例，默认 0.4）
   - 对上涨候选要求：
     - R_up ≥ k1 * ATR20 / close[t]
     - 最大回撤 ≤ max_reverse_ratio * R_up
   - 对下跌候选要求：
     - R_down ≥ k1 * ATR20 / close[t]
     - 最大反弹 ≤ max_reverse_ratio * R_down
   - 满足条件的候选段，认为是有效候选。

5. 为上涨 / 下跌候选定义趋势评分：
   - score_up = R_up / (1e-6 + 最大回撤)
   - score_down = R_down / (1e-6 + 最大反弹)

6. 去重与生成最终段：
   - 将所有候选段（上涨+下跌）放到一个列表，包含：symbol, t_start_idx, t_end_idx, direction（+1 或 -1）, length, total_return, max_reverse, score。
   - 按 score 从大到小排序。
   - 依次遍历候选段：
     - 如果当前候选与已选段列表中任何一段在时间上有重叠，则跳过；
     - 否则加入“最终单边段列表”。
   - 得到最终不重叠的单边行情段集合。

7. 把单边段切成“前 / 中 / 后”阶段（按累计涨跌幅比例）：
   - 对每一段：
     - 沿着 direction（+1 表示上涨，-1 表示下跌）计算从 t_start 到 t_end 的逐日累计涨跌幅（只考虑单边方向）。
     - 找出累计涨跌幅达到 1/3 和 2/3 总幅度的日期：
       - [t_start, date_1] 归为“前段”
       - (date_1, date_2] 归为“中段”
       - (date_2, t_end] 归为“后段”
     - 要注意处理长度较短的段，避免数组越界。

8. 打标签：
   - 对每个交易日 / 每个 symbol 生成一个整数标签 `label`：
     - label = +1：该日属于“上涨单边段的前段或中段”
     - label = -1：该日属于“下跌单边段的前段或中段”
     - label = 0：其他所有日子（包括单边段的后段 + 完全没有单边行情的日子）
   - 将 `label` 列加入原始 `df_all` 中，得到带标签的 DataFrame。

请将上述逻辑封装为清晰的函数，例如：
- `identify_trend_segments(df_symbol, ...) -> List[Segment]`
- `split_segments_into_phases(segments) -> phase_info`
- `assign_labels(df_all, segments, phases) -> df_labeled`

==================================================
【五、特征工程（只用过去信息）】
==================================================

写一个函数：
- `make_features(df: pd.DataFrame) -> pd.DataFrame`
- 输入为按 symbol、date 排序，并含有基础价格字段和 label 的 DataFrame。
- 输出为增加了一系列特征列的 DataFrame。

特征设计要求（全部用过去信息，不能泄露未来）：

1. 价格动量与突破：
   - 3 日、5 日、10 日收益率：feat_ret_3, feat_ret_5, feat_ret_10
   - 20 日最高价、最低价：rolling_high_20, rolling_low_20
   - 收盘在 20 日区间中的位置：
     - feat_price_pos_20 = (close - rolling_low_20) / (rolling_high_20 - rolling_low_20 + 1e-6)
   - 是否突破 20 日新高 / 新低（0/1）：
     - feat_break_high_20, feat_break_low_20

2. 均线与趋势：
   - MA_3, MA_5, MA_10, MA_20
   - feat_ma_5_20_diff = MA_5 - MA_20
   - feat_ma_5_20_ratio = MA_5 / (MA_20 + 1e-6)
   - 用 10 日窗口对收盘价做线性回归，得到：
     - feat_trend_slope_10
     - feat_trend_r2_10

3. 波动与 ATR：
   - ATR_14 或 ATR_20：feat_atr_14 或 feat_atr_20
   - 收益率的 5 日 / 20 日滚动标准差：
     - feat_vol_5, feat_vol_20
     - feat_vol_ratio_5_20 = feat_vol_5 / (feat_vol_20 + 1e-6)

4. 成交量与持仓量：
   - vol_ma_20 = 20 日成交量均值
   - feat_vol_ratio = volume / (vol_ma_20 + 1e-6)
   - oi_ma_20 = 20 日持仓量均值
   - feat_oi_ratio = open_interest / (oi_ma_20 + 1e-6)
   - feat_oi_chg_1 = open_interest - open_interest.shift(1)
   - feat_oi_chg_3 = open_interest.diff(3)
   - feat_oi_chg_rate_3 = feat_oi_chg_3 / (oi_ma_20 + 1e-6)

5. K 线位置：
   - feat_close_pos_in_bar = (close - low) / (high - low + 1e-6)

处理要求：
- 按 symbol 分组计算滚动指标，避免跨品种污染。
- 对窗口长度不足产生的 NaN，在最后统一丢弃这些行。
- 特征列统一以 `feat_` 开头命名。
- **注意**：由于数据仅有 11 个月（约 220 交易日），滚动窗口不宜过长（建议最大窗口 ≤ 20 日），避免丢弃过多初期数据。

==================================================
【六、数据集划分与标签处理】
==================================================

**重要说明：本地数据仅包含 2025 年 1 月至 11 月的数据。**

1. 在完成标签和特征后，得到 `df_feat`，包含：
   - date, symbol
   - label
   - 一系列 feat_ 前缀的特征列

2. 使用时间序列方式划分训练 / 验证 / 测试集：
   - 由于数据仅覆盖 2025 年 1-11 月（约 11 个月），请按以下方案划分：
     - **训练集**：2025-01-01 至 2025-08-31（约 8 个月，~73%）
     - **验证集**：2025-09-01 至 2025-10-15（约 1.5 个月，~14%）
     - **测试集**：2025-10-16 至 2025-11-30（约 1.5 个月，~13%）
   - 或者使用动态比例划分：
     - 自动检测数据的最早和最晚日期
     - 训练集：前 70% 的交易日
     - 验证集：中间 15% 的交易日
     - 测试集：最后 15% 的交易日
   - 必须保证：
     - 训练集时间 < 验证集时间 < 测试集时间
     - 禁止随机打乱后做普通交叉验证
   - **注意**：由于数据量有限（仅 11 个月），模型泛化能力可能受限，回测结果仅供参考。

3. 标签设计（至少实现多头模型）：
   - 多头模型标签：
     - y_long = 1 当 label = +1
     - y_long = 0 其他情况
   - 你可以同时给出空头模型的示例（y_short = 1 当 label=-1）。

4. 样本不平衡处理：
   - 单边前/中段通常是少数类，可以在模型中设置：
     - LightGBM 的 `scale_pos_weight` 或
     - class_weight / sample_weight
   - 实现一个简单的方式即可（例如根据正负样本比例设置 scale_pos_weight）。

==================================================
【七、模型训练（传统机器学习，使用 LightGBM）】
==================================================

1. 必须实现至少一个使用 LightGBM 的二分类模型（多头模型）：
   - 使用 `lightgbm.LGBMClassifier` 或相同功能接口。

2. 写一个训练函数：
   - `train_long_model(df_train, df_valid, feature_cols) -> model`
   - 步骤：
     - 从 df_train 提取 X_train（特征列）、y_train（y_long）
     - 从 df_valid 提取 X_valid、y_valid
     - 实例化 LGBMClassifier，设置基本参数：
       - num_leaves
       - max_depth
       - learning_rate
       - n_estimators
       - subsample
       - colsample_bytree
       - objective='binary'
       - scale_pos_weight（根据训练集正负样本比例设定）
     - 使用 early_stopping_rounds 在验证集上早停。
     - 输出或打印 AUC、准确率、召回率等指标。

3. 模型保存与预测：
   - 使用 joblib 保存模型到本地，例如：`models/long_model_lgbm.pkl`
   - 写一个预测函数：
     - `predict_long_proba(df, model, feature_cols) -> pd.Series`
     - 返回每一行对应的“多头单边前/中段”的概率 p_long（取正类概率）。

==================================================
【八、简单多头策略与回测示例】
==================================================

请实现一个简化的策略，仅用于演示如何从 `p_long` 变成交易信号并做回测：

1. 策略规则（仅多头）：
   - 输入：带有 date、symbol、close、feat_ 特征、label 以及预测概率 `p_long` 的测试集数据（按 date 排序）。
   - 使用简单假设：每次只在一个品种上开一笔多单（为了代码简单）。

   交易逻辑：
   - 没有持仓时：
     - 如果某日 `p_long > threshold_long`（例如 0.6），则在该日收盘价开多 1 单位。
   - 有持仓时：
     - 持仓超过 `max_holding_days`（例如 10 天）则在当日收盘价平仓。
     - 或浮动收益相对峰值回撤超过某个阈值（例如 2 * ATR）则止损平仓。

   简化处理：
   - 不考虑手续费和滑点，或用一个固定费率参数扣减。

2. 回测输出结果：
   - 记录每笔交易：开仓日、平仓日、持仓天数、开仓价、平仓价、单笔收益率。
   - 最终计算并打印：
     - 总交易次数
     - 胜率
     - 平均单笔收益率
     - 净值曲线（每日权益）
     - 最大回撤
     - 简单年化收益率（按日收益序列估算）

3. 可选：使用 matplotlib 画出净值曲线。

==================================================
【九、代码风格与主入口】
==================================================

1. 所有代码放在一个文件中，使用类型注解（type hints）和中文注释。
2. 在文件末尾提供一个 `if __name__ == "__main__":` 主入口示例：
   - 指定 `db_path = "futures.db"`
   - 调用 `load_history_from_db` 读取数据
   - **打印数据的时间范围和基本统计信息**（验证数据覆盖 2025-01 至 2025-11）
   - 调用单边行情识别与打标签函数
   - 调用特征工程函数生成特征
   - 按时间划分训练 / 验证 / 测试集（使用动态比例或固定日期阈值）
   - 训练 LightGBM 多头模型
   - 在测试集上预测 `p_long`，执行简单回测，并打印回测结果

总结：  
请根据以上所有要求，**输出完整、可运行的 Python 源代码**（不是伪代码），从 SQLite 读取 `futures.db` 中的期货主连数据（数据范围：2025 年 1 月至 11 月），识别 3–10 日单边行情，打标签，构建特征，用 LightGBM 训练传统机器学习模型，并基于模型信号做一个简单的多头策略回测示例。

**特别提醒**：
- 数据仅覆盖 2025 年约 11 个月，样本量有限，模型结果仅供学习参考。
- 代码应能自动检测数据的实际时间范围，并据此动态划分数据集。
- 在输出中打印数据统计信息（日期范围、品种数量、总样本数等）以便验证。
