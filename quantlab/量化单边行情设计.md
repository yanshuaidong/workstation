你是一名资深量化工程师，熟悉 Python、pandas、传统机器学习（尤其是 XGBoost / LightGBM / scikit-learn），也熟悉 SQLite 与期货时间序列回测。

我要你**直接写出完整可运行的 Python 代码**，实现一个从 SQLite 数据库读取数据 → 识别 3–10 日单边行情 → 打标签 → 特征工程 → 使用传统机器学习训练模型 → 简单策略回测 的完整流程。

特别要求：
- 只能使用传统机器学习（树模型、逻辑回归等），**禁止使用任何深度学习框架**（禁止 PyTorch、TensorFlow、Keras 等）。
- 不需要 GPU，加速全部用 CPU。
- 数据来源是一个名为 `futures.db` 的 SQLite 数据库，结构如下。

==================================================
【一、数据来源：SQLite futures.db 的表结构】
==================================================

数据库文件：`futures.db`
数据时间范围：2018 年 1 月至 2024 年 12 月（共约 7 年、~1700 交易日/品种，76 个活跃品种）

1. 合约主表：`contracts_main`

表结构（列名和含义如下）：

- `symbol`      TEXT PRIMARY KEY   合约代码（如 AU0, CU0）
- `name`        TEXT NOT NULL      合约名称（如 沪金主连）
- `exchange`    TEXT               交易所代码（如 SHFE, DCE）
- `is_active`   INTEGER DEFAULT 1  是否活跃（1=活跃, 0=非活跃）
- `created_at`  TEXT               创建时间
- `updated_at`  TEXT               更新时间

2. 历史行情表：每个合约一个独立表

- 表名格式：`hist_` + 合约代码小写，例如：symbol = 'AU0' → 表名 `hist_au0`
- 每个历史行情表字段：

  - `trade_date`    TEXT PRIMARY KEY   交易日期（YYYY-MM-DD）
  - `open_price`    REAL               开盘价
  - `high_price`    REAL               最高价
  - `low_price`     REAL               最低价
  - `close_price`   REAL               收盘价
  - `volume`        INTEGER            成交量（手）
  - `open_interest` INTEGER            持仓量（手）

==================================================
【二、整体代码结构与技术栈要求】
==================================================

1. 主要使用库：
   - sqlite3 或 SQLAlchemy（任选其一，sqlite3 更简单即可）
   - pandas
   - numpy
   - scikit-learn
   - lightgbm 或 xgboost（至少实现 LightGBM 版本）
   - matplotlib（可选，用于简单画图）

2. 所有代码写在**一个 .py 文件**中（例如 `futures_trend_ml.py`），我可以直接复制粘贴运行。

3. 代码结构建议拆成以下模块/函数（全部放在同一文件中）：
   - 数据读取与整合：
     - 连接 SQLite
     - 从 `contracts_main` 读取活跃合约（`is_active=1`）
     - 遍历这些合约，拼接对应的 `hist_{symbol.lower()}` 表数据，统一成一个总的 DataFrame
   - 单边行情识别与打标签
   - 特征工程（只用过去信息）
   - 时间序列划分训练集 / 验证集 / 测试集
   - 使用 LightGBM 的传统机器学习训练模型
   - 用模型概率生成交易信号 + 简单回测

4. 所有关键函数需要有清晰的 docstring 和中文注释，说明输入输出。

==================================================
【三、数据读取与基础预处理】
==================================================

请实现如下逻辑：

1. 写一个函数：
   - `get_active_contracts(conn) -> List[str]`
   - 功能：从 `contracts_main` 中查询所有 `is_active = 1` 的 `symbol`，返回 symbol 列表。

2. 写一个函数：
   - `load_history_from_db(db_path: str) -> pd.DataFrame`
   - 功能：
     - 连接 `futures.db`
     - 通过 `get_active_contracts` 获取活跃合约列表
     - 对每个 symbol：
       - 构造该合约的历史表名：`hist_` + symbol.lower()
       - 使用 `pd.read_sql_query` 从该表读取所有行
       - 把字段重命名成统一格式：
         - `trade_date` → `date`
         - `open_price` → `open`
         - `high_price` → `high`
         - `low_price` → `low`
         - `close_price` → `close`
         - `volume` → `volume`
         - `open_interest` → `open_interest`
       - 增加一列：`symbol` = 当前合约代码
     - 把所有合约的数据拼接成一个总表 `df_all`：
       - 包含：`date`, `symbol`, `open`, `high`, `low`, `close`, `volume`, `open_interest`
       - 将 `date` 转换为 datetime 类型
       - 按 `symbol`、`date` 排序
     - 返回 `df_all`

3. 在后续所有处理中，都以这个 `df_all` 为基础。

==================================================
【四、单边行情（3–10 日）识别与打标签】
==================================================

目标：从历史数据中自动识别 3–10 日的单边行情段（上涨或下跌），并把每段切成“前 / 中 / 后”阶段，然后给每一天打标签用于监督学习。

请按以下规则实现：

1. 按品种分组：
   - 对每个 `symbol` 的子 DataFrame（按 date 排序）单独处理。

2. 对每个起点日 t 和每个窗口长度 L ∈ [3, 10]：
   - 计算上涨候选：
     - R_up = (close[t+L-1] - close[t]) / close[t]
   - 计算下跌候选：
     - R_down = (close[t] - close[t+L-1]) / close[t]   （取正数，表示沿下跌方向的幅度）

3. 计算“最大逆向波动”：
   - 对上涨候选：
     - 区间 [t, t+L-1] 取最低价 low_min
     - 最大回撤 = (close[t] - low_min) / close[t]
   - 对下跌候选：
     - 区间 [t, t+L-1] 取最高价 high_max
     - 最大反弹 = (high_max - close[t]) / close[t]

4. 使用波动自适应阈值：
   - 为每个品种预先计算 20 日 ATR 或 20 日真实波动率（可用简单 ATR 实现）。
   - 设参数：
     - k1（总幅度相对 ATR 的倍数，默认 2.0）
     - max_reverse_ratio（最大逆向波动比例，默认 0.4）
   - 对上涨候选要求：
     - R_up ≥ k1 * ATR20 / close[t]
     - 最大回撤 ≤ max_reverse_ratio * R_up
   - 对下跌候选要求：
     - R_down ≥ k1 * ATR20 / close[t]
     - 最大反弹 ≤ max_reverse_ratio * R_down
   - 满足条件的候选段，认为是有效候选。

5. 为上涨 / 下跌候选定义趋势评分：
   - score_up = R_up / (1e-6 + 最大回撤)
   - score_down = R_down / (1e-6 + 最大反弹)

6. 去重与生成最终段：
   - 将所有候选段（上涨+下跌）放到一个列表，包含：symbol, t_start_idx, t_end_idx, direction（+1 或 -1）, length, total_return, max_reverse, score。
   - 按 score 从大到小排序。
   - 依次遍历候选段：
     - 如果当前候选与已选段列表中任何一段在时间上有重叠，则跳过；
     - 否则加入“最终单边段列表”。
   - 得到最终不重叠的单边行情段集合。

7. 把单边段切成“前 / 中 / 后”阶段（按累计涨跌幅比例）：
   - 对每一段：
     - 沿着 direction（+1 表示上涨，-1 表示下跌）计算从 t_start 到 t_end 的逐日累计涨跌幅（只考虑单边方向）。
     - 找出累计涨跌幅达到 1/3 和 2/3 总幅度的日期：
       - [t_start, date_1] 归为“前段”
       - (date_1, date_2] 归为“中段”
       - (date_2, t_end] 归为“后段”
     - 要注意处理长度较短的段，避免数组越界。

8. 打标签：
   - 对每个交易日 / 每个 symbol 生成一个整数标签 `label`：
     - label = +1：该日属于“上涨单边段的前段或中段”
     - label = -1：该日属于“下跌单边段的前段或中段”
     - label = 0：其他所有日子（包括单边段的后段 + 完全没有单边行情的日子）
   - 将 `label` 列加入原始 `df_all` 中，得到带标签的 DataFrame。

请将上述逻辑封装为清晰的函数，例如：
- `identify_trend_segments(df_symbol, ...) -> List[Segment]`
- `split_segments_into_phases(segments) -> phase_info`
- `assign_labels(df_all, segments, phases) -> df_labeled`

==================================================
【五、特征工程（只用过去信息）】
==================================================

写一个函数：
- `make_features(df: pd.DataFrame) -> pd.DataFrame`
- 输入为按 symbol、date 排序，并含有基础价格字段和 label 的 DataFrame。
- 输出为增加了一系列特征列的 DataFrame。

特征设计要求（全部用过去信息，不能泄露未来）：

1. 价格动量与突破：
   - 3 日、5 日、10 日收益率：feat_ret_3, feat_ret_5, feat_ret_10
   - 20 日最高价、最低价：rolling_high_20, rolling_low_20
   - 收盘在 20 日区间中的位置：
     - feat_price_pos_20 = (close - rolling_low_20) / (rolling_high_20 - rolling_low_20 + 1e-6)
   - 是否突破 20 日新高 / 新低（0/1）：
     - feat_break_high_20, feat_break_low_20

2. 均线与趋势：
   - MA_3, MA_5, MA_10, MA_20
   - feat_ma_5_20_diff = MA_5 - MA_20
   - feat_ma_5_20_ratio = MA_5 / (MA_20 + 1e-6)
   - 用 10 日窗口对收盘价做线性回归，得到：
     - feat_trend_slope_10
     - feat_trend_r2_10

3. 波动与 ATR：
   - ATR_14 或 ATR_20：feat_atr_14 或 feat_atr_20
   - 收益率的 5 日 / 20 日滚动标准差：
     - feat_vol_5, feat_vol_20
     - feat_vol_ratio_5_20 = feat_vol_5 / (feat_vol_20 + 1e-6)

4. 成交量与持仓量：
   - vol_ma_20 = 20 日成交量均值
   - feat_vol_ratio = volume / (vol_ma_20 + 1e-6)
   - oi_ma_20 = 20 日持仓量均值
   - feat_oi_ratio = open_interest / (oi_ma_20 + 1e-6)
   - feat_oi_chg_1 = open_interest - open_interest.shift(1)
   - feat_oi_chg_3 = open_interest.diff(3)
   - feat_oi_chg_rate_3 = feat_oi_chg_3 / (oi_ma_20 + 1e-6)

5. K 线位置：
   - feat_close_pos_in_bar = (close - low) / (high - low + 1e-6)

处理要求：
- 按 symbol 分组计算滚动指标，避免跨品种污染。
- 对窗口长度不足产生的 NaN，在最后统一丢弃这些行。
- 特征列统一以 `feat_` 开头命名。
- **注意**：数据量充足（7 年），可使用更长的滚动窗口（如 60、120、250 日），捕捉中长期趋势特征。建议设置预热期为 60 交易日。

==================================================
【六、数据集划分与标签处理】
==================================================

**数据说明：本地数据包含 2018-01-01 至 2024-12-31（约 7 年、~1700 交易日/品种）的期货主连日线数据，共 76 个活跃品种。**

1. 在完成标签和特征后，得到 `df_feat`，包含：
   - date, symbol
   - label
   - 一系列 feat_ 前缀的特征列

2. 数据集划分方案（推荐方案 A，可选方案 B/C）：

   **方案 A：固定年份划分（推荐）**
   - **训练集**：2018-01-01 至 2022-12-31（5 年，~71%）
   - **验证集**：2023-01-01 至 2023-12-31（1 年，~14%）
   - **测试集**：2024-01-01 至 2024-12-31（1 年，~14%）
   - 优点：以完整年份划分，覆盖多种市场周期，验证和测试集都有足够样本量。

   **方案 B：滚动窗口验证（Walk-Forward Validation）**
   - 适用于更严格的模型评估，模拟真实交易中的定期再训练。
   - 滚动窗口参数：
     - `train_window`：训练集长度（建议 3 年，~750 交易日）
     - `valid_window`：验证集长度（建议 6 个月，~125 交易日）
     - `test_window`：测试集长度（建议 6 个月，~125 交易日）
     - `step`：滚动步长（建议 6 个月，~125 交易日）
   - 实现方式：
     ```python
     def walk_forward_split(df, train_window=750, valid_window=125, test_window=125, step=125):
         """
         生成滚动窗口的 (train_df, valid_df, test_df) 迭代器
         """
         dates = df['date'].drop_duplicates().sort_values().values
         total_days = len(dates)
         required = train_window + valid_window + test_window
         
         for start in range(0, total_days - required + 1, step):
             train_end = start + train_window
             valid_end = train_end + valid_window
             test_end = valid_end + test_window
             
             train_dates = dates[start:train_end]
             valid_dates = dates[train_end:valid_end]
             test_dates = dates[valid_end:test_end]
             
             yield (
                 df[df['date'].isin(train_dates)],
                 df[df['date'].isin(valid_dates)],
                 df[df['date'].isin(test_dates)]
             )
     ```
   - 输出多个 fold 的回测结果，取平均或汇总分析。

   **方案 C：动态比例划分**
   - 自动检测数据的最早和最晚日期
   - 训练集：前 70% 的交易日
   - 验证集：中间 15% 的交易日
   - 测试集：最后 15% 的交易日

   **必须保证**：
   - 训练集时间 < 验证集时间 < 测试集时间
   - 禁止随机打乱后做普通交叉验证（时间序列数据必须保持时间顺序）
   - 验证集用于超参数调优和早停，测试集仅用于最终评估

3. 特征窗口与数据预热：
   - 由于数据量充足（7 年），滚动窗口可适当放宽：
     - 短期窗口：3, 5, 10 日
     - 中期窗口：20, 40, 60 日
     - 长期窗口：120, 250 日（可选，用于捕捉年度趋势）
   - 数据预热期：前 60 个交易日用于计算滚动指标，从第 61 个交易日开始生成有效样本
   - 各品种数据起始日期不同（如氧化铝仅 374 条），按品种单独处理预热

4. 标签设计（多头 + 空头双模型）：
   - **多头模型标签**：
     - y_long = 1 当 label = +1（上涨单边段的前/中段）
     - y_long = 0 其他情况
   - **空头模型标签**：
     - y_short = 1 当 label = -1（下跌单边段的前/中段）
     - y_short = 0 其他情况
   - 建议同时训练两个模型，分别捕捉多空机会。

5. 样本不平衡处理：
   - 单边前/中段通常是少数类（预计占比 10%-20%），需要处理不平衡问题。
   
   **方法 A：scale_pos_weight（推荐）**
   ```python
   neg_count = (y_train == 0).sum()
   pos_count = (y_train == 1).sum()
   scale_pos_weight = neg_count / pos_count  # 通常在 4-10 之间
   ```
   
   **方法 B：样本权重 sample_weight**
   ```python
   sample_weight = np.where(y_train == 1, neg_count / pos_count, 1.0)
   ```
   
   **方法 C：下采样多数类**
   - 对 label=0 的样本进行随机下采样，保持正负样本比例在 1:2 ~ 1:3
   - 适用于训练集样本量非常大的情况
   
   **方法 D：SMOTE 过采样（可选）**
   - 使用 imblearn 库对少数类进行合成过采样
   - 注意：对时间序列数据使用 SMOTE 需谨慎，可能引入未来信息

6. 数据质量检查：
   - 在划分数据集前，打印以下统计信息：
     ```python
     print(f"数据日期范围: {df['date'].min()} ~ {df['date'].max()}")
     print(f"总样本数: {len(df)}, 品种数: {df['symbol'].nunique()}")
     print(f"标签分布: +1={label_1_count}, -1={label_minus1_count}, 0={label_0_count}")
     print(f"正样本占比 (多头): {label_1_count / len(df) * 100:.2f}%")
     print(f"正样本占比 (空头): {label_minus1_count / len(df) * 100:.2f}%")
     ```
   - 检查各品种的数据完整性，剔除数据量过少的品种（如 < 250 交易日）

==================================================
【七、模型训练（传统机器学习，使用 LightGBM）】
==================================================

1. 必须实现至少一个使用 LightGBM 的二分类模型（多头模型）：
   - 使用 `lightgbm.LGBMClassifier` 或相同功能接口。

2. 写一个训练函数：
   - `train_long_model(df_train, df_valid, feature_cols) -> model`
   - 步骤：
     - 从 df_train 提取 X_train（特征列）、y_train（y_long）
     - 从 df_valid 提取 X_valid、y_valid
     - 实例化 LGBMClassifier，设置基本参数：
       - num_leaves
       - max_depth
       - learning_rate
       - n_estimators
       - subsample
       - colsample_bytree
       - objective='binary'
       - scale_pos_weight（根据训练集正负样本比例设定）
     - 使用 early_stopping_rounds 在验证集上早停。
     - 输出或打印 AUC、准确率、召回率等指标。

3. 模型保存与预测：
   - 使用 joblib 保存模型到本地，例如：`models/long_model_lgbm.pkl`
   - 写一个预测函数：
     - `predict_long_proba(df, model, feature_cols) -> pd.Series`
     - 返回每一行对应的“多头单边前/中段”的概率 p_long（取正类概率）。

==================================================
【八、简单多头策略与回测示例】
==================================================

请实现一个简化的策略，仅用于演示如何从 `p_long` 变成交易信号并做回测：

1. 策略规则（仅多头）：
   - 输入：带有 date、symbol、close、feat_ 特征、label 以及预测概率 `p_long` 的测试集数据（按 date 排序）。
   - 使用简单假设：每次只在一个品种上开一笔多单（为了代码简单）。

   交易逻辑：
   - 没有持仓时：
     - 如果某日 `p_long > threshold_long`（例如 0.6），则在该日收盘价开多 1 单位。
   - 有持仓时：
     - 持仓超过 `max_holding_days`（例如 10 天）则在当日收盘价平仓。
     - 或浮动收益相对峰值回撤超过某个阈值（例如 2 * ATR）则止损平仓。

   简化处理：
   - 不考虑手续费和滑点，或用一个固定费率参数扣减。

2. 回测输出结果：
   - 记录每笔交易：开仓日、平仓日、持仓天数、开仓价、平仓价、单笔收益率。
   - 最终计算并打印：
     - 总交易次数
     - 胜率
     - 平均单笔收益率
     - 净值曲线（每日权益）
     - 最大回撤
     - 简单年化收益率（按日收益序列估算）

3. 可选：使用 matplotlib 画出净值曲线。

==================================================
【九、代码风格与主入口】
==================================================

1. 所有代码放在一个文件中，使用类型注解（type hints）和中文注释。
2. 在文件末尾提供一个 `if __name__ == "__main__":` 主入口示例：
   - 指定 `db_path = "futures.db"`
   - 调用 `load_history_from_db` 读取数据
   - **打印数据的时间范围和基本统计信息**（验证数据覆盖 2018-01 至 2024-12）
   - 调用单边行情识别与打标签函数
   - 调用特征工程函数生成特征
   - 按时间划分训练 / 验证 / 测试集（推荐使用固定年份划分：训练 2018-2022，验证 2023，测试 2024）
   - 训练 LightGBM 多头模型（可选：同时训练空头模型）
   - 在测试集上预测 `p_long`，执行简单回测，并打印回测结果

总结：  
请根据以上所有要求，**输出完整、可运行的 Python 源代码**（不是伪代码），从 SQLite 读取 `futures.db` 中的期货主连数据（数据范围：2018 年 1 月至 2024 年 12 月，约 7 年），识别 3–10 日单边行情，打标签，构建特征，用 LightGBM 训练传统机器学习模型，并基于模型信号做一个简单的多头策略回测示例。

**特别提醒**：
- 数据覆盖约 7 年（2018-2024），样本量充足，可进行更严格的模型验证。
- 推荐使用固定年份划分：训练集 2018-2022（5 年），验证集 2023（1 年），测试集 2024（1 年）。
- 可选使用滚动窗口验证（Walk-Forward Validation）进行更稳健的评估。
- 在输出中打印数据统计信息（日期范围、品种数量、总样本数、各品种数据条数等）以便验证。
- 注意部分品种数据较短（如氧化铝 374 条、碳酸锂 352 条），可考虑剔除数据量过少的品种。
